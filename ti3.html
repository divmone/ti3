<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Шифрование Рабина</title>
    <style>
        .file-input {
            display: none;
        }
    </style>
</head>
<body>
<h1>Шифрование Рабина</h1>

<div class="card">
    <h2>Параметры шифрования</h2>

    <div class="input-group">
        <label for="p">Простое число p (p ≡ 3 mod 4)</label>
        <input type="number" id="p" min="2" placeholder="Введите простое число p">
    </div>

    <div class="input-group">
        <label for="q">Простое число q (q ≡ 3 mod 4)</label>
        <input type="number" id="q" min="2" placeholder="Введите простое число q">
    </div>

    <div class="input-group">
        <label for="b">Параметр b (0 ≤ b < n)</label>
        <input type="number" id="b" min="0" placeholder="Введите параметр b">
    </div>

    <div class="btn-group">
        <button id="encrypt" class="btn btn-success">Зашифровать</button>
        <button id="decrypt" class="btn btn-success">Расшифровать</button>
    </div>
</div>

<div class="card">
    <h2>Работа с файлами</h2>

    <div class="btn-group">
        <button id="readFile" class="btn">Загрузить файл</button>
        <button id="readEncrypted" class="btn">Загрузить зашифрованный файл</button>
        <button id="saveEncrypted" class="btn">Сохранить зашифрованный файл</button>
        <button id="saveDecrypted" class="btn">Сохранить расшифрованный файл</button>
    </div>

    <div id="error" class="error"></div>

    <div class="data-display">
        <p><strong>Загруженный файл:</strong> <span id="read-plaintext"></span></p>
        <p><strong>Загруженный зашифрованный файл:</strong> <span id="read-ciphertext"></span></p>
        <p><strong>Результат шифрования:</strong> <span id="encrypted-text"></span></p>
        <p><strong>Результат расшифровки:</strong> <span id="decrypted-text"></span></p>
    </div>
</div>

<input type="file" id="file-input" class="file-input">
<input type="file" id="encrypted-input" class="file-input">

<script>
    let pValue = 0;
    let qValue = 0;
    let bValue = 0;
    let nValue = 0;
    let byteArray = [];
    let intArray = [];
    let bytesToSave = [];
    let intToSave = [];

    const pInput = document.getElementById('p');
    const qInput = document.getElementById('q');
    const bInput = document.getElementById('b');
    const encryptBtn = document.getElementById('encrypt');
    const decryptBtn = document.getElementById('decrypt');
    const readFileBtn = document.getElementById('readFile');
    const readEncryptedBtn = document.getElementById('readEncrypted');
    const saveEncryptedBtn = document.getElementById('saveEncrypted');
    const saveDecryptedBtn = document.getElementById('saveDecrypted');
    const fileInput = document.getElementById('file-input');
    const encryptedInput = document.getElementById('encrypted-input');
    const errorDiv = document.getElementById('error');
    const readCiphertextSpan = document.getElementById('read-ciphertext');
    const readPlaintextSpan = document.getElementById('read-plaintext');
    const encryptedTextSpan = document.getElementById('encrypted-text');
    const decryptedTextSpan = document.getElementById('decrypted-text');

    encryptBtn.addEventListener('click', encryptData);
    decryptBtn.addEventListener('click', decryptData);
    readFileBtn.addEventListener('click', () => fileInput.click());
    readEncryptedBtn.addEventListener('click', () => encryptedInput.click());
    saveEncryptedBtn.addEventListener('click', saveEncryptedData);
    saveDecryptedBtn.addEventListener('click', saveDecryptedData);
    fileInput.addEventListener('change', handleFileRead);
    encryptedInput.addEventListener('change', handleEncryptedRead);

    function isPrime(n, k = 5) {
        if (n <= 1) return false;
        if (n <= 3) return true;
        if (n % 2 === 0) return false;

        let d = n - 1;
        let s = 0;
        while (d % 2 === 0) {
            d /= 2;
            s++;
        }

        for (let i = 0; i < k; i++) {
            const a = 2 + Math.floor(Math.random() * (n - 3));
            let x = fastPow(a, d, n);

            if (x === 1 || x === n - 1) continue;

            let j;
            for (j = 0; j < s - 1; j++) {
                x = fastPow(x, 2, n);
                if (x === n - 1) break;
            }

            if (j === s - 1) return false;
        }

        return true;
    }

    function fastPow(base, power, mod) {
        let result = 1n;
        let num = BigInt(base) % BigInt(mod);
        power = BigInt(power);
        mod = BigInt(mod);

        while (power > 0n) {
            if (power % 2n === 1n) {
                result = (result * num) % mod;
            }
            num = (num * num) % mod;
            power = power / 2n;
        }

        return Number(result);
    }

    function extendedGCD(a, b) {
        a = BigInt(a);
        b = BigInt(b);

        let [oldR, r] = [a, b];
        let [oldS, s] = [1n, 0n];
        let [oldT, t] = [0n, 1n];

        while (r !== 0n) {
            const quotient = oldR / r;
            [oldR, r] = [r, oldR - quotient * r];
            [oldS, s] = [s, oldS - quotient * s];
            [oldT, t] = [t, oldT - quotient * t];
        }

        return {
            gcd: Number(oldR),
            x: Number(oldS),
            y: Number(oldT)
        };
    }

    function modInverse(a, m) {
        const { gcd, x } = extendedGCD(a, m);
        if (gcd !== 1) return null;
        return ((x % m) + m) % m;
    }

    function showError(message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }

    function clearError() {
        errorDiv.textContent = '';
        errorDiv.style.display = 'none';
    }

    function displayData() {
        readCiphertextSpan.textContent = intArray.length > 20
            ? intArray.slice(0, 20).join(' ') + '...'
            : intArray.join(' ');

        readPlaintextSpan.textContent = byteArray.length > 20
            ? byteArray.slice(0, 20).join(' ') + '...'
            : byteArray.join(' ');

        encryptedTextSpan.textContent = intToSave.length > 20
            ? intToSave.slice(0, 20).join(' ') + '...'
            : intToSave.join(' ');

        decryptedTextSpan.textContent = bytesToSave.length > 20
            ? bytesToSave.slice(0, 20).join(' ') + '...'
            : bytesToSave.join(' ');
    }

    function encryptData() {
        clearError();

        pValue = parseInt(pInput.value);
        qValue = parseInt(qInput.value);
        bValue = parseInt(bInput.value);

        if (isNaN(pValue)) {
            showError('Введите простое число p');
            return;
        }

        if (isNaN(qValue)) {
            showError('Введите простое число q');
            return;
        }

        if (isNaN(bValue)) {
            showError('Введите параметр b');
            return;
        }

        if (!isPrime(pValue)) {
            showError('p должно быть простым числом');
            return;
        }

        if (!isPrime(qValue)) {
            showError('q должно быть простым числом');
            return;
        }

        if (pValue % 4 !== 3 || qValue % 4 !== 3) {
            showError('p и q должны быть ≡ 3 mod 4');
            return;
        }

        nValue = pValue * qValue;

        if (bValue < 0 || bValue >= nValue) {
            showError('b должно быть в диапазоне 0 ≤ b < n');
            return;
        }

        if (byteArray.length === 0) {
            showError('Нет данных для шифрования');
            return;
        }

        intToSave = [];
        for (let i = 0; i < byteArray.length; i++) {
            const m = byteArray[i];
            if (m >= nValue) {
                showError(`Байт ${m} больше или равен n=${nValue}. Увеличьте p и q.`);
                return;
            }
            const c = (m * (m + bValue)) % nValue;
            intToSave.push(c);
        }

        displayData();
    }

    function decryptData() {
        clearError();

        pValue = parseInt(pInput.value);
        qValue = parseInt(qInput.value);
        bValue = parseInt(bInput.value);

        if (isNaN(pValue) || isNaN(qValue) || isNaN(bValue)) {
            showError('Заполните все поля');
            return;
        }

        if (intArray.length === 0) {
            showError('Нет данных для расшифровки');
            return;
        }

        nValue = pValue * qValue;
        const b24 = modInverse(bValue * bValue, 4 * nValue);
        if (b24 === null) {
            showError('Не удалось найти обратный элемент для b² mod 4n');
            return;
        }

        bytesToSave = [];
        for (let i = 0; i < intArray.length; i++) {
            const c = intArray[i];
            if (c >= nValue) {
                showError(`Шифр ${c} больше или равен n=${nValue}`);
                return;
            }

            const D = (bValue * bValue + 4 * c) % nValue;

            const mp = fastPow(D, (pValue + 1) / 4, pValue);
            const mq = fastPow(D, (qValue + 1) / 4, qValue);

            const { gcd, x: yp, y: yq } = extendedGCD(pValue, qValue);
            if (gcd !== 1) {
                showError('p и q должны быть взаимно простыми');
                return;
            }

            const solutions = [
                (yp * pValue * mq + yq * qValue * mp) % nValue,
                (yp * pValue * mq - yq * qValue * mp) % nValue,
                (-yp * pValue * mq + yq * qValue * mp) % nValue,
                (-yp * pValue * mq - yq * qValue * mp) % nValue
            ].map(x => (x + nValue) % nValue);

            let found = false;
            let possibleM;
            for (const m of solutions) {
                possibleM = (m - bValue) * modInverse(2, nValue) % nValue;
                if (possibleM < 0) possibleM += nValue;

                if (possibleM >= 0 && possibleM < 256) {
                    bytesToSave.push(possibleM);
                    found = true;
                    break;
                }
            }

            if (!found) {
                showError(`Не удалось расшифровать блок ${c}`);
                return;
            }
        }

        displayData();
    }

    function handleFileRead(e) {
        clearError();
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const data = new Uint8Array(e.target.result);
            byteArray = Array.from(data);
            intArray = [];
            bytesToSave = [];
            intToSave = [];
            displayData();
        };
        reader.readAsArrayBuffer(file);
        e.target.value = '';
    }

    function handleEncryptedRead(e) {
        clearError();
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const data = new Uint8Array(e.target.result);
            intArray = [];

            for (let i = 0; i < data.length; i += 4) {
                let intValue = 0;
                for (let j = 0; j < 4 && i + j < data.length; j++) {
                    intValue = (intValue << 8) | data[i + j];
                }
                intArray.push(intValue);
            }

            byteArray = [];
            bytesToSave = [];
            intToSave = [];
            displayData();
        };
        reader.readAsArrayBuffer(file);
        e.target.value = '';
    }

    function saveEncryptedData() {
        if (intToSave.length === 0) {
            showError('Нет зашифрованных данных для сохранения');
            return;
        }

        const byteData = new Uint8Array(intToSave.length * 4);
        for (let i = 0; i < intToSave.length; i++) {
            const intValue = intToSave[i];
            byteData[i * 4] = (intValue >> 24) & 0xFF;
            byteData[i * 4 + 1] = (intValue >> 16) & 0xFF;
            byteData[i * 4 + 2] = (intValue >> 8) & 0xFF;
            byteData[i * 4 + 3] = intValue & 0xFF;
        }

        const blob = new Blob([byteData], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'encrypted.bin';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    function saveDecryptedData() {
        if (bytesToSave.length === 0) {
            showError('Нет расшифрованных данных для сохранения');
            return;
        }

        const byteData = new Uint8Array(bytesToSave);
        const blob = new Blob([byteData], { type: 'application/octet-stream' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'decrypted.bin';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
</script>
</body>
</html>